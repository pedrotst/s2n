// sampling.saw Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

///////////////////////////////////////////////////////////////////////////////
// Specifications

/* NOTES:

  - `get_rand_mod_len` uses the results of the aes_ctr_prf in a way
    that guarantees termination only probabilistically (given a true
    random source).

  - We can handle this, poorly, by giving an override that uses a ghost
    variable to determine the series of outputs of the prf.  Then we can
    symbolically execute with a concrete set of "random" values.  This
    could be better, but does at least let us simulate a complete
    execution of the `get_rand_mod_len`, and so check for memory safety.
*/

// NOTE: We have some large values to exercise the "too large"
//       path and have a 0 in case len is as small as 1.

let {{ prf_output = [ -1, -2, 1, 2, 25, 0, 5, 999
                    , 1023, 823, 111, 9876
                    , 1234, 63, 11, 6767 ] : [16][32] }};

prf_index <- crucible_declare_ghost_state "prf_index";
let prf_index_t = llvm_int 4;

// TODO: Add extra conditions on the prf state; see the full
//       aes_ctr_prf spec. This will be difficult - how many calls
//       must be possible for terminate? So we cannot easily specify
//       the requirement on `s.rem_invokations`

let aes_ctr_pfr_HACK_spec = do {

    ap <- out_ref (plain_type (llvm_array 4 i8));
    (b, bp) <- inout_ref aes_ctr_prf_state_T "prf_state";
    ix <- crucible_fresh_var "prf_index" prf_index_t;
    crucible_ghost_value prf_index ix;

    // NOTE: This invariant is need to avoid underflow
    crucible_precond {{ b.pos <= `AES256_BLOCK_SIZE }};

    crucible_execute_func [ap, bp, tm {{ 4:[32] }}];
    b' <- point_to aes_ctr_prf_state_T bp "s'";

    // NOTE: invariant is mantained
    crucible_postcond {{ b'.pos <= `AES256_BLOCK_SIZE }};

    crucible_ghost_value prf_index {{ ix+1 }};
    crucible_points_to ap (tm {{ split`{parts=4,each=8} (prf_output @ ix) }});
    crucible_return (tm {{ fromInteger`{[32]} SUCCESS }});
};

// NOTE: SAW does not terminate when simulating this with a symbolic
//       value for `len` (here, the `b` parameter). So in addition to setting
//       a specific stream of prf values, we set an arbitrary value of `b`.
//       Looking at the code, this affects the number of iterations,
//       but not other memory behavior.

let get_rand_mod_len_spec' = do {

    ap <- out_ref i32_T;
    let b = {{ 4:[32] }};
    let bp = tm b;

    // NOTE: This precondition is needed for terminiation
    crucible_precond {{ b > 0 }};

    (c, cp) <- inout_ref aes_ctr_prf_state_T "prf_state";

    // NOTE: This invariant is need to avoid underflow
    crucible_precond {{ c.pos <= `AES256_BLOCK_SIZE }};

    crucible_ghost_value prf_index {{ 0:[4] }};
    crucible_execute_func [ap, bp, cp];
    a <-crucible_fresh_var "rand_pos" i32;
    crucible_points_to ap (tm a); // ap gets set
    crucible_postcond {{ a < b }};
    c' <- point_to aes_ctr_prf_state_T cp "s'";

    // NOTE: Invariant continues to hold
    crucible_postcond {{ c'.pos <= `AES256_BLOCK_SIZE }};

    ret <- crucible_fresh_var "ret" i32;
    crucible_return (tm {{ ret }});
};

// NOTE: For callers we use a simplified setup that omits
//       mention of the ghost variable
let get_rand_mod_len_spec = do {

    ap <- out_ref i32_T;
    (b, bp) <- in_val i32_T "len";

    // NOTE: This precondition is needed for terminiation
    crucible_precond {{ b > 0 }};

    (c, cp) <- inout_ref aes_ctr_prf_state_T "prf_state";

    // NOTE: This invariant is need to avoid underflow
    crucible_precond {{ c.pos <= `AES256_BLOCK_SIZE }};

    crucible_execute_func [ap, bp, cp];
    a <-crucible_fresh_var "rand_pos" i32;
    crucible_points_to ap (tm a); // ap gets set
    crucible_postcond {{ a < b }};
    c' <- point_to aes_ctr_prf_state_T cp "s'";

    // NOTE: Invariant continues to hold
    crucible_postcond {{ c'.pos <= `AES256_BLOCK_SIZE }};
    ret <- crucible_fresh_var "ret" i32;
    crucible_return (tm {{ ret }});
};

// NOTE: In C, `make_odd_weight` has 3 parameters.  The compiler apparently
//       realized that `len`, the second parameter, is always R_BITS, and
//       has eliminated it from the LLVM parameter list.

let make_odd_weight_spec len = do {
    (a, ap) <- inout_ref (make_i8_T len) "a";
    (c, cp) <- inout_ref aes_ctr_prf_state_T "prf_state";

    // NOTE: This invariant is need to avoid underflow
    crucible_precond {{ c.pos <= `AES256_BLOCK_SIZE }};

    crucible_execute_func [ap, cp];
    a' <- point_to (make_i8_T len) ap "make_odd_weight_a'";
    c' <- point_to aes_ctr_prf_state_T cp "make_odd_weight_s'";

    // NOTE: This invariant still holds
    crucible_postcond {{ c'.pos <= `AES256_BLOCK_SIZE }};
};

let sample_uniform_r_bits_spec len = do {
    (ap) <- out_ref (make_i8_T len);
    (b, bp) <- in_ref seed_T "seed";
    (c, cp) <- in_val i32_T "must_be_odd";
    crucible_execute_func [ap, bp, cp];
    a' <- point_to (make_i8_T len) ap "a'"; // write to OUT parameter
    crucible_return (tm {{ fromInteger`{[32]} SUCCESS }});
};

let is_new2_spec = do {
    (a, ap) <- in_ref (make_i32_T FAKE_DV) "wlist";
    crucible_execute_func [ap, tm {{ 3:[32] }}];
    succ <- crucible_fresh_var "succ" i32;
    crucible_return (tm succ);
};

let is_new_spec = do {
    let ty = llvm_array FAKE_DV idx_t;
    (a, ap) <- in_ref (plain_type ty) "wlist";
    crucible_execute_func [ap, tm {{ `DV:[32] }}];
    succ <- crucible_fresh_var "succ" i32;
    crucible_return (tm succ);
};

// NOTE: We parameterize by the lengths of the `a` and `wlist1` parameters.
//       Must have weight < max (T1, FAKE_DV), or an assertion fails.
//       a_len_64 is the length of a `a` array, and is 1/8 times `a_len_bytes

let secure_set_bits_spec a_len_64 weight = do {
    (a ,ap) <- inout_ref (plain_type (llvm_array a_len_64 i64)) "a";
    (b, bp) <- inout_ref (idx_array_T weight) "wlist";
    crucible_execute_func [ap, bp, tm {{ 8*(`a_len_64:[32])}},
        tm {{ `weight:[32] }}];
};

/* NOTES:

  - There are some functions that use the result of `get_rand_mod_len`
    in a way that guarantees termination only probabilistically
    (given a true random source). Examples are `generate_sparse_fake_rep`
    and `generate_sparse_rep`.

  - We can handle this, poorly, by giving an override that uses a ghost
    variable to determine the series of outputs.  Then we can
    symbolically execute with a concrete set of "random" values.  This
    could be better, but does at least let us simulate a complete
    execution of the client, and so check for memory safety.
*/

// NOTE: We have some duplicate values to exercise the not `is_new` paths
let {{ random_data = [ 1, 5, 1, 2, 25, 100, 5, 999
                     , 1023, 823, 111, 9876, 1234
                     , 63, 11, 6767] : [16][32] }};

random_index <- crucible_declare_ghost_state "random_index";
let random_index_t = llvm_int 4;

let get_rand_mod_len_HACK_spec = do {

    ap <- out_ref i32_T;
    (b, bp) <- in_val i32_T "len";
    (c, cp) <- inout_ref aes_ctr_prf_state_T "prf_state";

    // NOTE: Invariant
    crucible_precond {{ c.pos <= `AES256_BLOCK_SIZE }};

    ix <- crucible_fresh_var "random_index" random_index_t;
    crucible_ghost_value random_index ix;
    crucible_execute_func [ap, bp, cp];
    c' <- point_to aes_ctr_prf_state_T cp "gen_rand_mod_len_s'";

    // NOTE: Invariant
    crucible_postcond {{ c'.pos <= `AES256_BLOCK_SIZE }};

    crucible_ghost_value random_index {{ix+1}};

    // NOTE: This is always less than `len
    crucible_points_to ap (tm {{(random_data @ ix) % b}});

    crucible_return (tm {{ fromInteger`{[32]} SUCCESS }});
};

// NOTE: `generate_sparse_rep` has a coding error, which does not
//       matter AS USED HERE, since the caller has actually already
//       zeroed out the `a` parameter, even though it is marked as
//       an OUT. But it is a latent error, and SAW rejects a specification
//       with `a` marked IN, as then uninitilized memory is referenced.

// TODO: Should we add a pre to ensure `a` comes in zeroed?

let generate_sparse_rep_spec len_a_64 len_w wt hack_p = do {

    (a,ap) <- inout_ref (plain_type (llvm_array len_a_64 i64)) "a";
    bp <- out_ref (idx_array_T len_w);
    (f, fp) <- inout_ref aes_ctr_prf_state_T "prf_state";

    // NOTE: Invariant
    crucible_precond {{ f.pos <= `AES256_BLOCK_SIZE }};

    if hack_p then
        // NOTE: This is a hack, point to start of random data!?
        crucible_ghost_value random_index {{ 0x0 }}
    else do { return (); };

    crucible_execute_func [ap, bp, tm {{ `wt:[32] }},
        tm {{ `len_w:[32] }}, tm {{ 8*(`len_a_64:[32]) }}, fp];
    f' <- point_to aes_ctr_prf_state_T fp "generate_sparse_fake_rep_s'";

    // NOTE: Invariant
    crucible_postcond {{ f'.pos <= `AES256_BLOCK_SIZE }};

    crucible_return (tm {{ 0:[32] }});
};

// NOTE: Only one parameter set to worry about, with
//       a:[R_PADDED_QW][64] and padded_len = R_PADDED_SIZE
let generate_sparse_fake_rep_spec hack_p = do {

    let a_T = make_i64_T R_PADDED_QW;
    (a,ap) <- inout_ref a_T "a";
    bp <- out_ref (idx_array_T FAKE_DV);
    (f, fp) <- inout_ref aes_ctr_prf_state_T "prf_state";

    // NOTE: Invariant
    crucible_precond {{ f.pos <= `AES256_BLOCK_SIZE }};
    if hack_p then
        // NOTE: This is a hack, point to start of random data!?
        crucible_ghost_value random_index {{0x0}}
    else do { return (); };

    crucible_execute_func [ap, bp, tm {{`R_PADDED_SIZE:[32]}}, fp];
    a' <- point_to a_T ap "a'"; // update the inout parameter
    b' <- point_to (idx_array_T FAKE_DV) bp "b'"; // set the out parameter
    f' <- point_to aes_ctr_prf_state_T fp "generate_sparse_fake_rep_s'";

    // NOTE: Invariant
    crucible_postcond {{ f'.pos <= `AES256_BLOCK_SIZE }};

    ret <- crucible_fresh_var "ret" i32;
    crucible_return (tm {{ret}});
};

let get_seeds_spec = do {
    let ty = (plain_type (llvm_struct "struct.double_seed_s"));
    ap <- out_ref ty;
    crucible_execute_func [ap];
    a' <- point_to ty ap "a'";
    res <- crucible_fresh_var "res" i32;
    crucible_return (tm res);
};

///////////////////////////////////////////////////////////////////////////////
// Proof commands

aes_ctr_prf_HACK_ov <- admit "aes_ctr_prf" [] aes_ctr_pfr_HACK_spec;

verify "get_rand_mod_len" [aes_ctr_prf_HACK_ov] get_rand_mod_len_spec';

get_rand_mod_len_ov <- admit "get_rand_mod_len" [] get_rand_mod_len_spec;

make_odd_weight_ov <- verify "make_odd_weight"
    [get_rand_mod_len_ov, count_ones_R_SIZE_ov]
    (make_odd_weight_spec R_SIZE);

get_rand_mod_len_HACK_ov <- admit "get_rand_mod_len" []
    get_rand_mod_len_HACK_spec;

is_new_ov <- verify "is_new" [] (is_new_spec);
is_new2_ov <- verify "is_new2" [] (is_new2_spec);

// NOTE: This is used an override for kem
get_seeds_ov_kem <- admit "get_seeds" [get_random_bytes_ov] (get_seeds_spec);

sample_uniform_r_bits_ov <- verify "sample_uniform_r_bits"
    [init_aes_ctr_prf_state_ov, aes_ctr_prf_ov2
    , make_odd_weight_ov, finalize_aes_ctr_prf_ov]
    (sample_uniform_r_bits_spec R_SIZE);

// NOTE: For generate_sparse_rep:
secure_set_bits_GSR_ov <- admit "secure_set_bits"
    [secure_cmp32_ov]
    (secure_set_bits_spec (eval_int {{( `N_PADDED_SIZE:[32])/8 }}) T1);

// NOTE: Code proof, with the faked random data
verify_pathsat "generate_sparse_rep"
    [ get_rand_mod_len_HACK_ov
    , secure_set_bits_GSR_ov
    ]
    (generate_sparse_rep_spec
        (eval_int {{ (`N_PADDED_SIZE:[32])/8 }}) N_BITS T1 true);

// NOTE: Override for callers, without the fake
generate_sparse_rep_ov <- admit "generate_sparse_rep" []
    (generate_sparse_rep_spec
    (eval_int {{( `N_PADDED_SIZE:[32])/8 }}) N_BITS T1 false);

/* NOTES: There are two calls to `secure_set_bits` in the CONSTANT_TIME version

  1. (a, wlist, padded_len, weight) from  generate_sparse_rep
     ... with parameters padded_len = N_PADDED_SIZE and weight=T1

  2. (a, wlist, padded_len, FAKE_DV) from generate_sparse_fake_rep and
     that called by crypto_kem_keypair, with
     padded_len = sizeof(p_sk[0]) = R_PADDED_SIZE
*/

// NOTE: For generate_sparse_fake_rep
secure_set_bits_GSFR_ov <- admit "secure_set_bits"
    [secure_cmp32_ov]
    (secure_set_bits_spec (eval_int {{( `R_PADDED_SIZE:[32])/8 }}) FAKE_DV);

// NOTE: Override for callers, without the faked data
generate_sparse_fake_rep_ov <- admit "generate_sparse_fake_rep" []
    (generate_sparse_fake_rep_spec false);

// NOTE: Code proof, with the faked random data
verify "generate_sparse_fake_rep"
    [get_rand_mod_len_HACK_ov
    , secure_cmp32_ov
    , secure_set_bits_GSFR_ov
    ]
    (generate_sparse_fake_rep_spec true);
