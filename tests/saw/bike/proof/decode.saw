// decode.saw Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

///////////////////////////////////////////////////////////////////////////////
// Specifications

let get_threshold_spec = do {
    (s, sp) <- in_ref red_r_T "s";
    crucible_execute_func [sp];
    crucible_return (crucible_term {{ 0:[32] }});
};

let transpose_spec = do {
    colp <- out_ref red_r_T;
    (row, rowp) <- in_ref red_r_T "row";
    crucible_execute_func [colp, rowp];
    col <- point_to red_r_T colp "col";
    crucible_postcond {{ col == c_transpose row }};
};

let split_e_spec   = do {
    sep <- out_ref generic_param_n_T;
    (e, ep) <- in_ref e_T "e";
    crucible_execute_func [sep, ep];
    se' <- point_to generic_param_n_T sep "raw.val";
    return ();
};

// NOTE: For calls with an uninitialized `ss` parameter; we only
//       write to the "dup1" part. So we can only refer to as much
//       memory as is written to, thus PTR(s).dup1: red_r_t
let compute_syndrome_spec = do {
    ap <- out_ref red_r_T;
    (b,bp) <- in_ref ct_T "ct";
    (c,cp) <- in_ref sk_T "sk";
    crucible_execute_func [ap, bp, cp];
    a' <- point_to red_r_T ap "a'";
    crucible_postcond {{ a' == compute_syndrome b c }};
};

// NOTE: For calls with an initialized `ss` parameter; we
//       update the "dup1" part.
let compute_syndrome_update_spec = do {
    (a,ap) <- inout_ref syndrome_T "s";
    (b,bp) <- in_ref ct_T "ct";
    (c,cp) <- in_ref sk_T "sk";
    crucible_execute_func [ap, bp, cp];
    a' <- point_to syndrome_T ap "s'";
    crucible_postcond {{ a' == compute_syndrome_update a b c }};
};

// NOTE: Like `compute_syndrome`, for calls with an uninitialized
//       syndrome we only write to the "dup1" part.
let recompute_syndrome_spec = do {
    // ap <- out_ref syndrome_T;
    ap <- out_ref red_r_T;
    (b, bp) <- in_ref ct_T "ct";
    (c, cp) <- in_ref sk_T "sk";
    (d, dp) <- in_ref e_T "e";
    crucible_execute_func [ap, bp, cp, dp];
    a' <- point_to red_r_T ap "syndrome'";
    return ();
};

let fix_error_spec = do {
    //(a, ap) <- inout_ref syndrome_T "s";
    (a, ap) <- inout_ref red_r_T "s";
    (b, bp) <- inout_ref e_T "e";
    (c, cp) <- inout_ref decode_ctx_T "ctx";
    (d, dp) <- in_ref sk_T "sk";
    (e, ep) <- in_ref ct_T "ct";
    crucible_execute_func [ap, bp, cp, dp, ep];
    a' <- point_to red_r_T ap "s'";
    b' <- point_to e_T bp "e'";
    c' <- point_to decode_ctx_T cp "ctx'";
    return ();
};

let decode_spec = do {
    ap <- out_ref e_T;
    (b, bp) <- inout_ref syndrome_T "s";
    (c, cp) <- in_ref ct_T "ct";
    (d, dp) <- in_ref sk_T "sk";
    e <- crucible_fresh_var "u" i32;
    crucible_precond {{ is_bounded_sk d }};
    crucible_execute_func [ap, bp, cp, dp, tm {{ e }}];
    res <- crucible_fresh_var "res" i32;
    crucible_return (tm res);
};

let decode_op_spec = do {
    ap <- out_ref e_T;
    (b,bp) <- inout_ref syndrome_T "s";
    (c, cp) <- in_ref ct_T "ct";
    (d, dp) <- in_ref sk_T "sk";
    e <- crucible_fresh_var "u" i32;
    crucible_precond {{ is_bounded_sk d }};
    crucible_execute_func [ap, bp, cp, dp, tm {{e}}];
    ret <- crucible_fresh_var "return" i32;
    crucible_return (crucible_term {{ret}});
    a' <- point_to e_T ap "e'";
    b' <- point_to syndrome_T bp "s'";
    crucible_postcond {{ (a', b', ret) == decode zero b c d e }} ;
};

///////////////////////////////////////////////////////////////////////////////
// Proof commands

// NOTE: This proof is not possible with the current floating point
//       suport in SAW
get_threshold_ov <- admit "get_threshold" [count_ones_R_BITS_ov]
    (get_threshold_spec);

transpose_ov <- verify "transpose" [] transpose_spec;
split_e_ov <- verify "split_e" [] (split_e_spec);

compute_syndrome_ov <- verify_unint  "compute_syndrome"
  [ gf2x_mod_mul_ov4
  , gf2x_add_ov4
  , convert_to_redundant_rep_ov
  , transpose_ov
  , secure_clean_ov_4RPS, secure_clean_ov_2RPS ]
  [ "gf2x_mod_mul", "convert_to_redundant_rep", "c_transpose"]
  compute_syndrome_spec;

compute_syndrome_update_ov <- verify_unint  "compute_syndrome"
    [ gf2x_mod_mul_ov4
    , gf2x_add_ov4
    , convert_to_redundant_rep_ov
    , transpose_ov
    , secure_clean_ov_4RPS, secure_clean_ov_2RPS ]
    ["gf2x_mod_mul", "gf2x_add", "convert_to_redundant_rep", "c_transpose"]
    compute_syndrome_update_spec;

recompute_syndrome_ov <- verify "recompute_syndrome"
    [ cyclic_product_ov
    , compute_syndrome_ov
    , split_e_ov
    , secure_clean_ov_GPNT
    , gf2x_add3_left_ov1 ]
    recompute_syndrome_spec;

fix_error1_ov <- verify "fix_error1"
    [find_error1_ov, recompute_syndrome_ov] fix_error_spec;

fix_black_error_ov <- verify "fix_black_error"
    [find_error2_ov, recompute_syndrome_ov] fix_error_spec;

fix_gray_error_ov <- verify "fix_gray_error"
    [find_error2_ov, recompute_syndrome_ov] fix_error_spec;

decode_op_ov <- admit "decode" [] decode_op_spec;
